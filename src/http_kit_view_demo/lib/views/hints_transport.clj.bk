(ns http-kit-view-demo.lib.views.hints-transport
  (:require
    [de.data.error-handling.core :as eh]
    [de.data.messaging.core :refer [conn]]
    [langohr.channel :as lch]
    [langohr.exchange :as le]
    [langohr.basic     :as lb]
    [langohr.queue     :as lq]
    [langohr.consumers :as lc]
    [clojure.edn :as edn]
    [views.core :refer [add-hint! refresh-views!]]))

;; View Delta Messages channel
;; Note, it is unclear how safe sharing a channel bewteen mutliple threads
;; is. They are supposedly thread safe, though reportedly things can still
;; go wrong depending on the order and type of commands issued on them.
(defonce hint-ch (atom nil))

(def update-exchange "de.update")

(defn init!
  []
  (reset! hint-ch (lch/open @conn))
  (le/fanout @hint-ch update-exchange {:durable true :auto-delete false}))

(defn put-hints!
  "Broadcast a view hint message."
  [hints]
  (lb/publish @hint-ch update-exchange "" (pr-str hints) {:content-type "application/edn" :persistent true}))

;; We create separate channels for the subscriber and put-hints! It's recommened that
;; each thread have it's own channel.
(defn- start-listener
  [conn queue-name view-system]
  (let [ch      (lch/open conn)
        handler (fn [ch metadata ^bytes payload]
                  (try
                    (if-let [data (edn/read-string (String. payload "UTF-8"))]
                      (refresh-views! view-system (:msg data))
                      #_(doseq [h (:msg data)] (add-hint! view-system h)))
                    (catch Exception e (eh/log-exception e))))
        thread  (Thread. (fn [] (lc/subscribe ch queue-name handler {:auto-ack true})))]
  (.start thread)))

;; IMPORTANT: We've had all sorts of problems with queues sticking around not deleting
;; and collecting jobs when this is declared durable and non-exlusive. It's unclear
;; if langohr would even reconnect to an auto-named queue on rabbitmq failure in a
;; HA setup. In any case, we can tolerate lost view updates in this scenario. It's better
;; than taking the system down! Non-durable may also provide a performance improvement.
(defn listen-for-hints!
  "Returns a channel bound to an update message queue."
  [view-system]
  (let [ch (lch/open @conn)
        q  (.getQueue (lq/declare ch "" {:exclusive true :durable false :auto-delete true}))]
    (start-listener @conn q view-system)
    (lq/bind ch q update-exchange)
    (lch/close ch)))
